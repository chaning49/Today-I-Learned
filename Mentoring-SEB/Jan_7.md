# 🧑🏻‍💻멘토링 1주차 - 1월 7일(토)

코드스테이츠 메인 프로젝트 멘토링을 진행하면서 멘토님께서 해주신 질문과 그에 대한 답변을 정리해보려고 합니다. <br>
정확하지 않은 내용이 있을 수도 있기 때문에 피드백은 완전 환영합니다! 😆😆

<br>

## 📌목차
<br>

## 🐤질문 정리!
### 1. 현재 사용하는 SDK는 무엇인가요?

📢 저는 spring boot로 개발하고 있고, SDK는 azul의 OpenJDK 11 LTS 버전을 사용한다.

<br>

### 1-1. 해당 버전을 사용하는 이유는?

OpenJDK 11은 자바 11 버전입니다. 선택한 이유는 LTS 버전 중에서 안정적이고, 성능 개선이 되어 있는 버전이기 때문에 사용했다.
1. 자바 11에 새로 추가된 기능을 이용할 수 있습니다. String 클래스에 새로운 메소드 추가(isBlank, strip ...)
2. 소스 파일 실행이 javac를 통한 컴파일 없이 스크립트로 가능하여 편리해졌다.
3. GC의 성능이 개선되니다. (Z GC, Epsilon 등)
4. LTS이기 때문에 버전에 대한 장기적인 지원이 가능하다.

<br>

### 📚추가 지식 쌓기

- JDK 8 버전(뛰어난 안정성으로 지금까지도 많이 사용중이다.)
  - 람다식 및 메서드 참조 도입
  - 컬렉션에 Stream API 사용 가능
  - 인터페이스 내부에 default 메서드 선언 가능
  - Optional 클래스 도입 등

- JDK 17
  - 텍스트 블록 추가
  - 의사 난수 생성기 기능 향상
  - switch 문 기능 향상
  - 봉인 클래스 추가 등

<br>

### 2. 지금 작성하는 Application은 멀티 프로세스로 동작 될까요? 멀티 스레드로 동작 될까요? 

Spring Boot(내장 Tomcat 웹 서버)의 경우 멀티 스레드 방식으로 동작한다.
일반적으로 멀티 스레드에서는 클라이언트 요청 발생 > 스레드 생성 > 요청 처리 순서로 동작한다. 
하지만 클라이언트가 많아지면 스레드를 생성하고 제거하는 데에 비용과 오버헤드가 발생한다.

<br>

이를 해결해기 위해 Spring Boot에서는 __스레드 풀(Thread Pool)__ 방식을 사용한다. 
스레드 풀 방식은 미리 특정 개수의 스레드를 스레드 풀에 만들어두고 필요할 때마다 가져다 사용한다. 
클라이언트 요청이 있는 풀의 경우, 풀에 있는 스레드 개수보다 요청이 많아지면 스레드를 새로 생성한다. 
재사용 가능하다는 장점이 있다. 
그래서 사전에 pool에 저장될 스레드의 개수를 적절히 생성하는 것이 중요다.

<br>

스프링의 경우는 기본적으로 Thread-safe 하지 않지만 스프링 빈은 무상태로 설계하는 관행, 스프링 빈의 전역 변수에는 final을 사용하는 관행이 있다. 그래서 Thread-safe 해진 것이다.

<br>

### 2-1. 공유되는 자원은 무엇일까요?

- 공유자원: 스레드가 동시성으로 실행될 때, 여러 개의 스레드가 접근 가능한 자원을 공유자원이라고 한다.
- 공유 자원에 스레드 여러 개가 동시에 접근하면 에러가 발생한다.
- 스레드는 프로세스 내에서 Stack은 따로 할당 받고, Code, Data, Heap 영역은 공유한다.

<br>

### 2-2. 공유되는 자원은 어떤 문제점이 있을까요?

- 여러 개의 스레드가 동일한 데이터 공간(Critical Section, 임계 영역)을 공유하면서 이들을 수정한다는 점에 필연적으로 생기는 문제이다.
- 멀티 프로세스의 프로그램은 문제가 생기면 해당 프로세스가 중단되거나 중단 시키고 다시 시작 하면된다. 하지만 멀티 스레드 방식의 프로그램에서는 하나의 스레드가 자신이 사용하던 데이터 공간을 망가뜨린다면, 해당 데이터 공간을 공유하는 모든 스레드를 망가뜨릴 수 있다.
- 임계영역(공유 변수 영역): 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원(자료 구조 또는 장치)을 접근하는 코드의 일부를 말한다.

<br>

### 📚추가 지식 쌓기
![멘토링_1월_7일](https://user-images.githubusercontent.com/79316402/212903723-0eba19c9-696f-42fd-8d4e-6c7d739c4fb3.png)

- 프로세스
  - 프로그램이 실행되어 돌아가는 상태, 사용자가 작성한 프로그램이 운영체제에 의해 메모리 공간을 할당받아 실행 중인 것을 말한다. 
  - 컴퓨터는 여러 프로세스를 함께 실행시킨다. 
  - 프로세스 = 프로그램에 사용되는 데이터와 메모리 등의 자원 + 스레드
  - 동시성(Concurrency): 조금씩 여러 작업을 돌아가면서 진행하는 방법, 사람이 자각할 수 없는 속도로 Context Switching(진행중인 작업을 바꾸는 것)이 일어나 동시에 일어나는 것처럼 느껴진다.
  - 병렬성(Parallelism): 프로세서 하나에 코어 여러 개가 달려서 각각 동시에 작업을 수행하는 것(듀얼, 코어, 쿼드 코어 등등)

- 프로세스의 메모리 구조
  - code 영역: 프로그램 코드
  - data 영역: 코드 실행시 사용되는 데이터(전역 변수, static 변수)
  - heap 영역: 동적으로 할당되는 메모리
  - stack 영역: 지역 변수, 매개 변수, 리턴 값

- 멀티 프로세스
  - 하나의 애플리케이션을 여러 개의 프로세스로 구성하여 각 프로세스가 하나의 작업을 처리하도록 하는 것이다.
  - 안정성: 여러 개의 자식 프로세스 중 하나에 문제가 발생해도, 다른 자식 프로세스에 영향이 확산되지 않는다.
  - 구현이 비교적 간단하고, 각 프로세스들이 독립적으로 동작하며 자원도 서로 다르게 할당된다.
  - IPC: 프로세스 간 통신 방법(프로세스 간에는 별도의 통신 방법이 필요하다.)
  - 메모리 사용량이 많다.
  - 스케쥴링에 따라 Context Switch가 많아지고, 성능 저하가 생길 수 있다.

- 스레드
  - 프로세스 내에서 실제로 작업을 수행하는 주체를 의미한다. 모든 프로세스에는 한 개 이상의 스레드가 존재하여 작업을 수행한다.

- 멀티 스레드
  - 하나의 애플리케이션을 여러 개의 스레드로 구성하여 하나의 스레드가 하나의 작업을 처리하도록 하는 것이다. 한 프로세스 안에서도 여러 작업들이 동시에 진행되는 것이 멀티 스레드이다.
  - 일반적으로 멀티스레드를 사용하는 이유는 사용자와 상호작용하는 애플리케이션에서 단일 스레드로 Network 또는 DB 와 같은 긴 작업(Long-running task) 을 수행하는 경우 해당 작업을 처리하는 동안 사용자와 상호작용이 불능인 상태가 될 수 있기 때문이다. (IO가 일어났을 경우와 똑같다.)
  - 교착상태가 발생하지 않도록 주의해야 한다. -> 동기화로 해결 가능!
  - 스레드는 프로세스 내에서 각각 Stack만 따로 할당받고 Code, Data, Heap 영역은 공유한다.

- 멀티 스레드 장점
  - 응답성이 좋다: 프로그램의 일부분(자식 스레드)이 오류 또는 긴 작업으로 인해 중단되어도 프로그램이 계속 수행된다.
  - 자원 공유가 쉽다: 스레드들은 부모 프로세스의 자원과 메모리를 공유할 수 있다.
  - 프로세스를 할당하는 것보다 스레드를 할당하는 것이 비용이 적다.
  - 멀티 프로세서 구조에서 각각의 스레드가 다른 프로세서에서 병렬로 수행될 수 있다.

- 멀티 스레드 단점
  - 구현 및 테스트, 디버깅이 어렵다.
  - 너무 많은 스레드 사용은 오버헤드를 발생시킨다.
  - 자식 스레드 중 하나에 문제가 생긴경우 전체 프로세스에 영향을 줄 수 있다.
  - 공유 자원에 스레드 여러 개가 동시에 접근하면 Error❗ Thread-safe(여러 스레드로부터 동시 접근이 발생해도 프로그램 실행에 문제가 없는 것)를 고려하자.

- 프로세스 vs 스레드
  - 프로세스는 컴퓨터 자원을 각자 분할해서 사용하는 반면, 스레드는 프로세스마다 주어진 전체 자원을 함께 사용하기 때문에 속도, 효율에서 뛰어나다.
  - 프로세스는 자원을 공유하지 않지만, 스레드는 자원을 공유한다.

<br>

### 3. lang package에서 Object 클래스는 무엇인가요?

- 자바의 최상위 클래스이다.
- 11개의 메서드를 가지고 있다. (toString, equals, clone, hashcode, finalize, wait, notify)

<br>

### 3-1. 최상위 클래스로 알고들 계셨는데, 상속을 사용하나요? 인터페이스로 구현하나요? 

- 상속, 컴파일러가 자동으로 extends Object를 추가한다.

<br>

### 3-2. 역할은 무엇일까요? 

- OS와 JVM 사이에서 관리하는 역할을 맡는다.
- 모든 클래스의 최고 조상 클래스로 Object 클래스의 모든 멤버는 모든 클래스에서 바로 사용이 가능하다.

<br>

### 3-3. equals와 hashCode 차이점은 무엇이고 구현에 유의점은 무엇일까요?

- equals: 등가 비교 연산(==)과 동일하게 스택 메모리 값(주소)을 비교, equals 메소드는 원본과 대조한다. 주소가 같으면 true를 리턴한다. 쉽게 말해 참조 변수(주소를 저장)를 비교한다.
- hashCode: 객체의 주소값을 해시코드로 반환한다. 메모리의 주소, 해시의 키를 매개변수로 값을 가져온다. 16진수 값은 힙 메모리 주소이다. 메모리의 주소가 같다는 것은 인스턴스가 같다는 말이다.

<br>

### 4. JVM의 메모리 프로세스
![멘토링_1월_7일_1](https://user-images.githubusercontent.com/79316402/212911653-5be0fc7a-2acc-4132-aff1-3a5a8059f005.png)

- 메소드 영역
    
    메소드 영역은 JVM이 시작할 때 생성되고 모든 스레드가 공유하는 영역이다. 메소드 영역에서는 코드에서 사용되는 class들을 클래스 로더로 읽어 클래스 별로 static field와 constant, method code, constructor code 등을 분류해서 저장한다.
    
- 힙 영역
    
    힙 영역은 객체와 배열이 생성되는 영역입니다. 여기에 생성된 객체와 배열은 JVM 스택 영역의 변수나 다른 객체의 필드에서 참조한다. 만일 참조하는 변수나 필드가 없다면 의미없는 객체가 되기 때문에 JVM에서는 garbage collector로 처리를 한다.
    
- JVM 스택 영역
    
    JVM 스택은 메소드를 호출할 때마다 frame을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다.

<br>

### 5. Garbage Collection

- 자바의 메모리 관리 방법 중의 하나로 JVM(자바 가상 머신)의 **Heap 영역**에서 **동적으로 할당했던 메모리** 중 **필요 없게 된 메모리 객체(garbage)를 모아 주기적으로 제거**하는 프로세스이다.
- Heap 영역에서 어디서든 참조하고 있지 않은 객체(Unreachable)들이 발생하게 되면 이러한 객체들을 주기적으로 가비지 컬렉터가 제거해주는 것이다.
- Java에서는 가비지 컬렉터가 메모리 관리를 대행해주기 때문에 Java 프로세스가 한정된 메모리를 효율적으로 사용할수 있게 하고, 개발자 입장에서 메모리 관리, 메모리 누수(Memory Leak) 문제에서 대해 관리하지 않아도 되어 오롯이 **개발에만 집중**할 수 있다는 장점이 있다.
- 자동으로 처리해준다 해도 메모리가 언제 해제되는지 정확하게 알 수 없어 제어하기 힘들며, 가비지 컬렉션(GC)이 동작하는 동안에는 다른 동작을 멈추기 때문에 **오버헤드**가 발생되는 문제점이 있다.(STW)
- **STW (Stop The World)**
    
    GC를 수행하기 위해 JVM이 프로그램 실행을 멈추는 현상을 의미.
    
    GC가 작동하는 동안 GC 관련 Thread를 제외한 모든 Thread는 멈추게 되어 서비스 이용에 차질이 생길 수 있다.

<br>

### 6. String과 StringBuffer(or StringBuilder)

- String
  - 불변: String 타입은 한 번 할당된 공간이 변하지 않기 떄문에 immutable 자료형이라고 한다.
  - String 변수의 값을 바꿀 때, 값이 '변경'된 것이 아니라 새로운 String 객체를 생성하고 그 객체를 참조하는 것이다. 그렇게 되면 이전에 생성되어 메모리에 적재되어 있던 String 객체의 메모리 영역은 Garbage에 있다가 GC에 의해 해제되어 사라진다.
  - 그래서 변경되지 않는 문자열을 자주 참조하는 경우 유용하다. 하지만 추가, 수정, 삭제 등의 연산이 자주 일어나야 하는 경우에는 힙 영역에 많은 Garbage가 생성되어 힙 메모리 부족으로 Application의 성능 저하를 일으킬 수도 있다.

- 자바 String을 불변으로 설정한 이유
  1. 캐싱: String을 불변으로 만들어 String pool에 각 리터럴 문자열의 하나만 저장하며 다시 사용하거나 캐싱에 이용 가능하며 그 결과로 힙 공간을 절약할 수 있다는 장점이 있다.
  2. 보안: 사용자의 크리덴셜 관련된 내용들은 보통 String을 사용하는데, 만약 이 값이 변할 수 있게 되면 참조하고 있는 값을 변경하여 Application에 보안 문제를 일으킬 수 있다.
  3. 동기화 : 불변이기 때문에 동시에 실행되는 여러 스레드에서 안정적이게 공유가 가능하다.

- StringBuffer / StringBuilder
  - 문자열을 연산(추가하거나 변경) 할 때 주로 사용하는 자료형이다.
  - 객체의 공간이 부족해지는 경우 버퍼의 크기를 유연하게 늘려주어 mutable하게 사용할 수 있다.
  - 그래서 문자열의 추가,수정,삭제가 빈번하게 발생할 경우에 사용한다.
  
- StringBuffer와 StringBuilder의 차이(Thread-safe)
  - StringBuffer: 내부적으로 버퍼(buffer)라고 하는 독립적인 공간을 가지게 되어, 문자열을 바로 추가할 수 있어 공간의 낭비도 없으며 문자열 연산 속도도 매우 빠르다는 특징이 있다. 동기화를 지원하기 때문에 Thread-safe하다.
  - StringBuilder: StringBuffer와 기본 기능은 같다. 하지만 단일 스레드에서 성능이 가장 뛰어나고, 동기화를 지원하지 않기 때문에 Thread-safe하지 않다.

- String과 StringBuffer의 차이
  - String 자료형만 으로도, `+` 연산이나 `concat()` 메소드로 문자열을 이어붙일수 있다.
    하지만 덧셈(+) 연산자를 이용해 String 인스턴스의 문자열을 결합하면, 내용이 합쳐진 새로운 String 인스턴스를 생성하게 되어, 따라서 문자열을 많이 결합하면 결합할수록 공간의 낭비 뿐만 아니라 속도 또한 매우 느려지게 된다는 단점이 있다.

- 결론: 자주 변하지 않는 문자열을 사용한다면 String 객체를 사용하는 것이 적합하고, 추가, 수정, 삭제 등의 연산이 자주 필요하다면 StringBuffer를 사용하는 것이 최적이다.

<br>

### 7. String 클래스가 implement 받는 Serializable과 Comparable<String>, **CharSequence**는 무엇인가?

- Serializable: java.io 패키지의 인터페이스이다. 해당 인터페이스를 구현하는 클래스에 의해서 직렬화가 가능해진다.
- Comparable<String>: Comparable 인터페이스는 객체를 정렬하는 데 사용되는 메소드인 compareTo() 메소드를 정의하고 있다. 자바에서 같은 타입의 인스턴스를 서로 비교해야만 하는 클래스들은 모두 Comparable 인터페이스를 구현하고 있기 때문에 String에서도 구현하고 있는 것이다.(*기본 정렬 순서는 오름차순)
- CharSequence: char 값이 나열된 인터페이스이다. 이 인터페이스는 다양한 종류의 문자 시퀀스에 대해 읽기 전용 액세스를 제공한다. CharSequence는 변경이 필수가 아니다. 따라서, 가변 클래스와 불변 클래스 모두 이 인터페이스를 구현한다.

<br>
  
### 7-1. equals의 파라미터가 왜 Object인지?

- 최상위 클래스인 Object 클래스에 equals가 이미 구현되어 있다. Object 클래스에 구현된 equals메서드는 두 개의 참조변수가 같은 객체를 참조하고 있는지만 판단할 수 있기 때문에 String 클래스에서 오버라이딩하여 재정의하기 때문에 파라미터는 Object 타입인 것이다.

### 7-2. 인터페이스가 3개인 이유?

1. String 클래스의 Serializable은 직렬화를 위해 사용한다. 파일에서 읽거나 쓰고, 다른 서버로 전송하기 위해서는 직렬화가 필요하다.
2. Comparable은 객체를 정렬하기 위해 사용하는데, String 클래스에서도 정렬을 하는 기능이 포함되기 때문에 사용한다.
3. String 객체는 charSequence를 구현하여 문자열의 형태를 만드는 것이기 때문에 필요하다.

### 7-3. String 클래스의 구조는?

- String 클래스는 Object 클래스의 자식 클래스이면서 Serializable, Comparable<String>, charSequence 인터페이스를 구현한다.
- String의 생성 방식
  - literal 방식: String 변수에 직접 "문자열"을 넣게 되면 Heap 메모리 내에 String pool이라는 곳에 저장되고, 해당 문자열의 주소가 String 변수에 저장된다. 그래서 동일한 문자열은 동일한 메모리 주소를 가지게 되는 것이다.
  - new 키워드 방식: 

### 7-4. charSequence가 왜 인터페이스로 구현돼 있을까?

- charSequence는 문자의 시퀀스를 나타내는 인터페이스로 String이 charSequence를 직접 구현하는 구현체로서의 역할을 수행하기 때문이다.

### 📚추가 지식 쌓기
- Serialize와 Deserialize
  - Serialize(자바 내부 Object or Data → byte 타입)
    객체의 직렬화를 뜻한다. 자바 시스템 내부에서 사용되는 Object 또는 Data를 외부의 자바 시스템에서도 사용할 수 있도록 byte 형태로 데이터를 변환하는 기술이다.
    메모리 관점에서 말하면 JVM의 메모리에 상주(힙 또는 스택)하고 있는 객체 데이터를 바이트 형태로 변환하는 기술을 뜻한다.
    
  - Deserializable(byte 타입 → Object or Data)
    byte로 변환된 Data를 원래대로 Object나 Data로 변환하는 기술을 역직렬화(Deserialize)라고 한다.
    직렬화된 바이트 형태의 데이터를 객체로 변환해서 JVM으로 상주시키는 형태이다.
